// this code is autogenerated, do not check it into to your code repository

// ref lib/zixir/compiler/python_ffi.ex:11
const std = @import("std");

// Dynamic library handle
var python_lib: ?*std.DynLib = null;
var python_initialized: bool = false;
var python_version: i32 = 0;

// Opaque types
const PyObject = opaque {};

// Function type declarations (optional for nullable)
const Py_Initialize_t = fn () void;
const Py_Finalize_t = fn () void;
const Py_IsInitialized_t = fn () c_int;
const PyImport_ImportModule_t = fn ([*c]const u8) ?*PyObject;
const PyObject_GetAttrString_t = fn ([*c]const u8, [*c]const u8) ?*PyObject;
const PyObject_CallObject_t = fn (?*PyObject, ?*PyObject) ?*PyObject;
const PyUnicode_AsUTF8_t = fn (?*PyObject) [*c]const u8;
const PyArg_ParseTuple_t = fn (?*PyObject, [*c]const u8, ...) c_int;
const Py_BuildValue_t = fn ([*c]const u8, ...) ?*PyObject;
const Py_DECREF_t = fn (?*PyObject) void;
const Py_XDECREF_t = fn (?*PyObject) void;
const Py_INCREF_t = fn (?*PyObject) void;
const PyTuple_New_t = fn (isize) ?*PyObject;
const PyTuple_SetItem_t = fn (?*PyObject, isize, ?*PyObject) c_int;
const PyFloat_FromDouble_t = fn (f64) ?*PyObject;
const PyLong_FromLong_t = fn (c_long) ?*PyObject;
const PyLong_AsLong_t = fn (?*PyObject) c_long;
const PyFloat_AsDouble_t = fn (?*PyObject) f64;
const PyList_New_t = fn (isize) ?*PyObject;
const PyList_SetItem_t = fn (?*PyObject, isize, ?*PyObject) c_int;
const PyList_Append_t = fn (?*PyObject, ?*PyObject) c_int;
const PyErr_Occurred_t = fn () ?*PyObject;
const PyErr_Clear_t = fn () void;
const PyErr_Print_t = fn () void;

// Function pointers (optional for nullable)
var Py_Initialize: ?*const Py_Initialize_t = null;
var Py_Finalize: ?*const Py_Finalize_t = null;
var Py_IsInitialized: ?*const Py_IsInitialized_t = null;
var PyImport_ImportModule: ?*const PyImport_ImportModule_t = null;
var PyObject_GetAttrString: ?*const PyObject_GetAttrString_t = null;
var PyObject_CallObject: ?*const PyObject_CallObject_t = null;
var PyUnicode_AsUTF8: ?*const PyUnicode_AsUTF8_t = null;
var PyArg_ParseTuple: ?*const PyArg_ParseTuple_t = null;
var Py_BuildValue: ?*const Py_BuildValue_t = null;
var Py_DECREF: ?*const Py_DECREF_t = null;
var Py_XDECREF: ?*const Py_XDECREF_t = null;
var Py_INCREF: ?*const Py_INCREF_t = null;
var PyTuple_New: ?*const PyTuple_New_t = null;
var PyTuple_SetItem: ?*const PyTuple_SetItem_t = null;
var PyFloat_FromDouble: ?*const PyFloat_FromDouble_t = null;
var PyLong_FromLong: ?*const PyLong_FromLong_t = null;
var PyLong_AsLong: ?*const PyLong_AsLong_t = null;
var PyFloat_AsDouble: ?*const PyFloat_AsDouble_t = null;
var PyList_New: ?*const PyList_New_t = null;
var PyList_SetItem: ?*const PyList_SetItem_t = null;
var PyList_Append: ?*const PyList_Append_t = null;
var PyErr_Occurred: ?*const PyErr_Occurred_t = null;
var PyErr_Clear: ?*const PyErr_Clear_t = null;
var PyErr_Print: ?*const PyErr_Print_t = null;

// Detect available Python version
fn detect_python_version() i32 {
  // Try loading Python 3.12, 3.11, 3.10 in order
  const versions = [_][*c]const u8{"python3.12", "python3.11", "python3.10", "python3"};
  
  for (versions) |ver| {
    const allocator = std.heap.page_allocator;
    const lib_name = std.fmt.allocPrint(allocator, "lib{s}.so", .{ver}) catch continue;
    defer allocator.free(lib_name);
    
    python_lib = std.DynLib.open(lib_name) catch {
      continue;
    };
    
    // Try to load symbols
    if (load_python_symbols()) {
      return get_version_number(ver);
    }
    
    python_lib.?.close();
    python_lib = null;
  }
  
  return 0; // No Python found
}

fn get_version_number(version: [*c]const u8) i32 {
  var major: i32 = 0;
  var minor: i32 = 0;
  var i: usize = 0;
  while (version[i] != 0) : (i += 1) {
    if (version[i] == '3') {
      major = 3;
      i += 1;
      if (version[i] == '.') {
        i += 1;
        minor = (version[i] - '0');
      }
      break;
    }
  }
  
  return (major * 100) + minor;
}

fn load_python_symbols() bool {
  Py_Initialize = python_lib.?.lookup(*const Py_Initialize_t, "Py_Initialize") catch return false;
  Py_Finalize = python_lib.?.lookup(*const Py_Finalize_t, "Py_Finalize") catch return false;
  Py_IsInitialized = python_lib.?.lookup(*const Py_IsInitialized_t, "Py_IsInitialized") catch return false;
  PyImport_ImportModule = python_lib.?.lookup(*const PyImport_ImportModule_t, "PyImport_ImportModule") catch return false;
  PyObject_GetAttrString = python_lib.?.lookup(*const PyObject_GetAttrString_t, "PyObject_GetAttrString") catch return false;
  PyObject_CallObject = python_lib.?.lookup(*const PyObject_CallObject_t, "PyObject_CallObject") catch return false;
  PyUnicode_AsUTF8 = python_lib.?.lookup(*const PyUnicode_AsUTF8_t, "PyUnicode_AsUTF8") catch return false;
  PyArg_ParseTuple = python_lib.?.lookup(*const PyArg_ParseTuple_t, "PyArg_ParseTuple") catch return false;
  Py_BuildValue = python_lib.?.lookup(*const Py_BuildValue_t, "Py_BuildValue") catch return false;
  Py_DECREF = python_lib.?.lookup(*const Py_DECREF_t, "Py_DECREF") catch return false;
  Py_XDECREF = python_lib.?.lookup(*const Py_XDECREF_t, "Py_XDECREF") catch return false;
  Py_INCREF = python_lib.?.lookup(*const Py_INCREF_t, "Py_INCREF") catch return false;
  PyTuple_New = python_lib.?.lookup(*const PyTuple_New_t, "PyTuple_New") catch return false;
  PyTuple_SetItem = python_lib.?.lookup(*const PyTuple_SetItem_t, "PyTuple_SetItem") catch return false;
  PyFloat_FromDouble = python_lib.?.lookup(*const PyFloat_FromDouble_t, "PyFloat_FromDouble") catch return false;
  PyLong_FromLong = python_lib.?.lookup(*const PyLong_FromLong_t, "PyLong_FromLong") catch return false;
  PyLong_AsLong = python_lib.?.lookup(*const PyLong_AsLong_t, "PyLong_AsLong") catch return false;
  PyFloat_AsDouble = python_lib.?.lookup(*const PyFloat_AsDouble_t, "PyFloat_AsDouble") catch return false;
  PyList_New = python_lib.?.lookup(*const PyList_New_t, "PyList_New") catch return false;
  PyList_SetItem = python_lib.?.lookup(*const PyList_SetItem_t, "PyList_SetItem") catch return false;
  PyList_Append = python_lib.?.lookup(*const PyList_Append_t, "PyList_Append") catch return false;
  PyErr_Occurred = python_lib.?.lookup(*const PyErr_Occurred_t, "PyErr_Occurred") catch return false;
  PyErr_Clear = python_lib.?.lookup(*const PyErr_Clear_t, "PyErr_Clear") catch return false;
  PyErr_Print = python_lib.?.lookup(*const PyErr_Print_t, "PyErr_Print") catch return false;
  
  return true;
}

/// Initialize Python interpreter
pub fn init_python() i32 {
  if (python_initialized) {
    return 1;
  }
  
  const version = detect_python_version();
  if (version == 0) {
    return 0; // No Python found
  }
  
  python_version = version;
  if (Py_Initialize) |init_fn| {
    init_fn();
  }
  python_initialized = true;
  return version;
}

/// Check if Python is initialized
pub fn is_python_initialized() i32 {
  if (Py_IsInitialized) |init_fn| {
    return if (python_initialized and init_fn() != 0) 1 else 0;
  }
  return 0;
}

/// Cleanup Python
pub fn finalize_python() void {
  if (python_initialized) {
    if (Py_Finalize) |finalize_fn| {
      finalize_fn();
    }
    python_initialized = false;
    
    if (python_lib) |lib| {
      lib.close();
      python_lib = null;
    }
  }
}

/// Call Python function with arguments
pub fn python_call(module: [*c]const u8, function: [*c]const u8, args_json: [*c]const u8, result_buf: [*c]u8, buf_size: usize) i32 {
  _ = args_json;
  
  if (!python_initialized) {
    const msg = "Python not initialized";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  
  // Import module
  const module_obj = PyImport_ImportModule.?(module);
  if (module_obj == null) {
    if (PyErr_Print) |print_fn| {
      print_fn();
    }
    const msg = "Module not found";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  if (Py_DECREF) |dec_fn| {
    defer dec_fn(module_obj);
  }
  
  // Get function
  const func_obj = PyObject_GetAttrString.?(function, module_obj);
  if (func_obj == null) {
    if (PyErr_Print) |print_fn| {
      print_fn();
    }
    const msg = "Function not found";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  if (Py_DECREF) |dec_fn| {
    defer dec_fn(func_obj);
  }
  
  // Build argument tuple (empty for now)
  const args = PyTuple_New.?(0);
  if (args == null) {
    const msg = "Failed to create args";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  defer Py_DECREF.?.(args);
  
  // Call function
  const result = PyObject_CallObject.?(func_obj, args);
  if (result == null) {
    PyErr_Print.?.();
    const msg = "Python call failed";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  defer Py_DECREF.?.(result);
  
  // Convert result to string
  const result_str = PyUnicode_AsUTF8.?(result);
  if (result_str == null) {
    const f = PyFloat_AsDouble.?(result);
    if (f != 0.0 or PyLong_AsLong.?(result) != 0) {
      const allocator = std.heap.page_allocator;
      const num_str = std.fmt.allocPrint(allocator, "{d}", .{f}) catch {
        const msg = "Conversion failed";
        const l = @min(msg.len, buf_size);
        @memcpy(result_buf[0..l], msg);
        return -@as(i32, @intCast(l));
      };
      defer allocator.free(num_str);
      const len = @min(num_str.len, buf_size);
      @memcpy(result_buf[0..len], num_str);
      return @as(i32, @intCast(len));
    }
    
    const msg = "Cannot convert result";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  
  const len = @min(std.mem.len(result_str), buf_size);
  @memcpy(result_buf[0..len], result_str[0..len]);
  return @as(i32, @intCast(len));
}

/// Create NumPy array from float array
pub fn numpy_array_from_floats(data: [*c]const f64, count: usize, result_buf: [*c]u8, buf_size: usize) i32 {
  if (!python_initialized) {
    const msg = "Python not initialized";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  
  // Import numpy
  const numpy_module_name = "numpy";
  const numpy_module = PyImport_ImportModule.?(numpy_module_name);
  if (numpy_module == null) {
    const msg = "NumPy not available";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  defer Py_DECREF.?.(numpy_module);
  
  // Get array function
  const array_func_name = "array";
  const array_func = PyObject_GetAttrString.?(array_func_name, numpy_module);
  if (array_func == null) {
    const msg = "numpy.array not found";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  defer Py_DECREF.?.(array_func);
  
  // Create Python list from data
  const py_list = PyList_New.?(count);
  if (py_list == null) {
    const msg = "Failed to create list";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  defer Py_DECREF.?.(py_list);
  
  var i: usize = 0;
  while (i < count) : (i += 1) {
    const py_float = PyFloat_FromDouble.?(data[i]);
    if (py_float == null) {
      const msg = "Failed to create float";
      const len = @min(msg.len, buf_size);
      @memcpy(result_buf[0..len], msg);
      return -@as(i32, @intCast(len));
    }
    _ = PyList_SetItem.?(py_list, @as(isize, @intCast(i)), py_float);
  }
  
  // Create tuple with (list,)
  const args = PyTuple_New.?(1);
  if (args == null) {
    const msg = "Failed to create args";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  defer Py_DECREF.?.(args);
  _ = PyTuple_SetItem.?(args, 0, py_list);
  
  // Call numpy.array
  const result = PyObject_CallObject.?(array_func, args);
  if (result == null) {
    PyErr_Print.?.();
    const msg = "numpy.array call failed";
    const len = @min(msg.len, buf_size);
    @memcpy(result_buf[0..len], msg);
    return -@as(i32, @intCast(len));
  }
  defer Py_DECREF.?.(result);
  
  // Return success indicator
  const msg = "numpy_array_created";
  const len = @min(msg.len, buf_size);
  @memcpy(result_buf[0..len], msg);
  return @as(i32, @intCast(len));
}

/// Check if module is available
pub fn has_module(name: [*c]const u8) i32 {
  if (!python_initialized) {
    return 0;
  }
  
  const module = PyImport_ImportModule.?(name);
  if (module == null) {
    return 0;
  }
  Py_DECREF.?.(module);
  return 1;
}

/// Get Python version as string
pub fn get_python_version(version_buf: [*c]u8, buf_size: usize) i32 {
  if (python_version == 0) {
    const msg = "No Python";
    const len = @min(msg.len, buf_size);
    @memcpy(version_buf[0..len], msg);
    return -1;
  }
  
  const major = @divTrunc(python_version, 100);
  const minor = python_version % 100;
  const allocator = std.heap.page_allocator;
  const version_str = std.fmt.allocPrint(allocator, "3.{d}.{d}", .{ major - 3, minor }) catch {
    return -1;
  };
  defer allocator.free(version_str);
  
  const len = @min(version_str.len, buf_size);
  @memcpy(version_buf[0..len], version_str);
  return @as(i32, @intCast(len));
}
