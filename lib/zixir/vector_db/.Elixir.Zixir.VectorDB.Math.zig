// this code is autogenerated, do not check it into to your code repository

// ref lib/zixir/vector_db/math.ex:15
const std = @import("std");
const math = std.math;

// ============================================
// Distance Calculations
// ============================================

/// Calculate cosine similarity between two vectors
/// Returns value between -1 and 1 (1 = identical)
pub fn cosine_similarity(a: []const f64, b: []const f64) f64 {
  if (a.len != b.len or a.len == 0) return 0.0;
  
  var dot: f64 = 0.0;
  var norm_a: f64 = 0.0;
  var norm_b: f64 = 0.0;
  
  // SIMD-friendly loop
  var i: usize = 0;
  while (i < a.len) : (i += 1) {
    dot += a[i] * b[i];
    norm_a += a[i] * a[i];
    norm_b += b[i] * b[i];
  }
  
  const denom = math.sqrt(norm_a) * math.sqrt(norm_b);
  if (denom == 0.0) return 0.0;
  
  return dot / denom;
}

/// Calculate Euclidean distance between two vectors
pub fn euclidean_distance(a: []const f64, b: []const f64) f64 {
  if (a.len != b.len) return std.math.inf(f64);
  
  var sum: f64 = 0.0;
  var i: usize = 0;
  while (i < a.len) : (i += 1) {
    const diff = a[i] - b[i];
    sum += diff * diff;
  }
  
  return math.sqrt(sum);
}

/// Calculate dot product of two vectors
pub fn dot_product(a: []const f64, b: []const f64) f64 {
  if (a.len != b.len) return 0.0;
  
  var sum: f64 = 0.0;
  for (a, b) |x, y| {
    sum += x * y;
  }
  return sum;
}

/// Normalize vector to unit length (for cosine similarity)
pub fn normalize(vector: []const f64) []f64 {
  var norm: f64 = 0.0;
  for (vector) |v| {
    norm += v * v;
  }
  norm = math.sqrt(norm);
  
  var result = std.heap.page_allocator.alloc(f64, vector.len) catch return &[_]f64{};
  
  if (norm == 0.0) {
    // Return zero vector if input is zero
    @memset(result, 0.0);
    return result;
  }
  
  for (vector, 0..) |v, i| {
    result[i] = v / norm;
  }
  return result;
}

// ============================================
// Simplified HNSW Index (Linear Search)
// ============================================

const HNSWIndex = struct {
  dimensions: usize,
  max_elements: usize,
  metric: Metric,
  count: usize,
  
  // Simple arrays (max 10000 elements for now)
  vectors: [10000][]f64,
  ids: [10000][]const u8,
  deleted: [10000]bool,
  
  const Metric = enum {
    cosine,
    euclidean,
    dot,
  };
};

var global_index: ?*HNSWIndex = null;

/// Initialize HNSW index (simplified version)
pub fn hnsw_init(dimensions: usize, max_elements: usize, ef_construction: usize, M: usize, random_seed: u64, metric: []const u8) ?*HNSWIndex {
  _ = ef_construction;
  _ = M;
  _ = random_seed;
  
  const index = std.heap.page_allocator.create(HNSWIndex) catch return null;
  
  index.dimensions = dimensions;
  index.max_elements = max_elements;
  index.count = 0;
  
  // Parse metric
  if (std.mem.eql(u8, metric, "cosine")) {
    index.metric = .cosine;
  } else if (std.mem.eql(u8, metric, "euclidean")) {
    index.metric = .euclidean;
  } else {
    index.metric = .dot;
  }
  
  // Initialize deleted flags
  for (0..10000) |i| {
    index.deleted[i] = true;  // Mark all as deleted initially
  }
  
  global_index = index;
  return index;
}

/// Add vector to index
pub fn hnsw_add(index: *HNSWIndex, id: []const u8, vector: []const f64) bool {
  if (index.count >= index.max_elements or index.count >= 10000) {
    return false;
  }
  
  const idx = index.count;
  
  // Copy vector
  const vec_copy = std.heap.page_allocator.alloc(f64, vector.len) catch return false;
  @memcpy(vec_copy, vector);
  index.vectors[idx] = vec_copy;
  
  // Copy ID
  const id_copy = std.heap.page_allocator.dupe(u8, id) catch return false;
  index.ids[idx] = id_copy;
  
  // Mark as not deleted
  index.deleted[idx] = false;
  
  index.count += 1;
  return true;
}

/// Search index (linear search for now)
pub fn hnsw_search(index: *HNSWIndex, query: []const f64, top_k: usize, metric: []const u8) ?[]const u8 {
  // Update metric if needed
  if (std.mem.eql(u8, metric, "cosine")) {
    index.metric = .cosine;
  } else if (std.mem.eql(u8, metric, "euclidean")) {
    index.metric = .euclidean;
  } else {
    index.metric = .dot;
  }
  
  // Simple linear search
  var results: [100]struct { idx: usize, score: f64 } = undefined;
  var result_count: usize = 0;
  
  for (0..index.count) |i| {
    if (!index.deleted[i]) {
      const dist = switch (index.metric) {
        .cosine => 1.0 - cosine_similarity(query, index.vectors[i]),
        .euclidean => euclidean_distance(query, index.vectors[i]),
        .dot => -dot_product(query, index.vectors[i]),
      };
      
      const score = switch (index.metric) {
        .cosine => 1.0 - dist,
        .euclidean => 1.0 / (1.0 + dist),
        .dot => -dist,
      };
      
      if (result_count < 100) {
        results[result_count] = .{ .idx = i, .score = score };
        result_count += 1;
      }
    }
  }
  
  // Simple bubble sort by score (descending)
  var sort_i: usize = 0;
  while (sort_i < result_count) : (sort_i += 1) {
    var sort_j: usize = sort_i + 1;
    while (sort_j < result_count) : (sort_j += 1) {
      if (results[sort_j].score > results[sort_i].score) {
        const temp = results[sort_i];
        results[sort_i] = results[sort_j];
        results[sort_j] = temp;
      }
    }
  }
  
  // Format results as "id1:score1,id2:score2,..."
  var output_buf: [4096]u8 = undefined;
  var output_len: usize = 0;
  
  const actual_top_k = @min(top_k, result_count);
  for (0..actual_top_k) |i| {
    if (i > 0) {
      output_buf[output_len] = ',';
      output_len += 1;
    }
    
    const id = index.ids[results[i].idx];
    const score = results[i].score;
    
    // Write id
    @memcpy(output_buf[output_len..], id);
    output_len += id.len;
    
    // Write colon
    output_buf[output_len] = ':';
    output_len += 1;
    
    // Write score (simplified - just write as integer for now)
    const score_int = @as(i64, @intFromFloat(score * 1000));
    var score_buf: [20]u8 = undefined;
    const score_str = std.fmt.bufPrint(&score_buf, "{d}", .{score_int}) catch continue;
    @memcpy(output_buf[output_len..], score_str);
    output_len += score_str.len;
  }
  
  // Allocate and return result
  const result = std.heap.page_allocator.alloc(u8, output_len) catch return null;
  @memcpy(result, output_buf[0..output_len]);
  return result;
}

/// Mark vector as deleted
pub fn hnsw_mark_deleted(index: *HNSWIndex, id: []const u8) bool {
  for (0..index.count) |i| {
    if (!index.deleted[i] and std.mem.eql(u8, index.ids[i], id)) {
      index.deleted[i] = true;
      return true;
    }
  }
  return false;
}

/// Free HNSW index
pub fn hnsw_free(index: *HNSWIndex) void {
  // Free all vectors and IDs
  for (0..index.count) |i| {
    if (!index.deleted[i]) {
      std.heap.page_allocator.free(index.vectors[i]);
      std.heap.page_allocator.free(index.ids[i]);
    }
  }
  std.heap.page_allocator.destroy(index);
  global_index = null;
}
